<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Unit 2</title>
    <link rel="stylesheet" href="DSA_unit_2.css">
</head>
<body>

   <h4>1)QUEUE</h4>
    i) Queue is a Non-primitive linear data structure.<br>
    ii)It is an homogenous collection of element in which new elements are added at one end called the Rear end and the existing element are delected from other end called the front end.<br>
    iii)The first added element will be the first to be remove from the queue sothat queue is called FIFO(first-in-first-out).<br>
    iv)In queue Every insert operation Rear is incremented by one <br>
    <pre>                     R = R + 1 </pre>
    <h4>2)WRITE A ALGORITHAM FOR INSERTION OF QUEUE</h4>
    <pre>STEP-1:- Begin
        STEP-2:- if Rear = N Then 
               print "Overflow & Exit"
        STEP-3:- Input new item
        STEP-4:- Rear <- Rear+1
        STEP-5:- queue[Rear] <- item
        STEP-6:- exit.
        </pre>
        <h4>32)WRITE A ALGORITHAM FOR DELETION OF QUEUE</h4>
        <pre>STEP-1:- Begin
            STEP-2:- if Front = -1 Then 
                   print "underflow & Exit"
            STEP-3:- set item <- queue[Front]
            STEP-4:- Front <- Front + 1
            STEP-5:- print "item deleted"
            STEP-6:- exit.</pre>

<h4>3)PUSH AND POP CODE USING QUEUE</h4>
<pre>#include< stdio.h>
#define MAX_SIZE 3
int queue[MAX_SIZE];
int front = -1;
int rear = -1;
int main(){
    int choice,item;
    printf("1.insert\n2.delete\n3.display\n4.exit\n");
    while (1)
    {
    printf("Enter your choice:- ");
    scanf("%d",&choice);
    switch (choice)
    {
    case 1 :
    {
        if(rear==MAX_SIZE)
        {
            printf("Overflow & Exit...\n");
        }else{
            printf("Enter the number:- ");
            scanf("%d",&item);
            if(front == -1)
            {
                front = rear = 0;
            }else{
                rear++;
            }
            queue[rear] = item;
            printf("Item Inserted \n");
        }
    }break;
    case 2:
    {
        if(front == -1)
        {
            printf("Underflow & Exit... \n");
        }else{
            item = queue[front];
            if(front == rear){
                front = rear = -1;
            }else{
                front++;
            }printf("Item Deleted:- \n");
        }break;
    }
    case 3:
    {
        if(front == -1){
            printf("Queue is empty.\n");
        }else{
            printf("Queue element:- ");
            for(int i=front;i<=rear;i++){
                printf("%d ",queue[i]);
            }printf("\n");
        }break;
    }
    case 4:{
        printf("Exit\n");
        return 0;
    }
    default:
        break;
    }
    }
}</pre>

    <h4>4)DIFFERENCE BETWEEN STACK AND QUEUE</h4>
<pre>
       STACK                          QUEUE
__________________________|_______________________________
i)Stack follow LIFO       |i)Queue follow FIFO operation
operation i.e - last-     |i.e - first-in-first-out.
in-first-out              |
ii)Insertion and delection|ii)Insertion and delection takes 
take place one end.This   |place on opposite end.
end is called top of      | 
stack .                   |
iii)Stack perform two     |iii)Queue perform two operation
operation i.e 1) PUSH     | i.e 1)Rear
          2)POP       |     2)Front
iv)PUSH -> used to insert |iv)REAR -> Used to insert the
the element in stack.     |element in queue. 
v)POP -> Used to delete   |v)FRONT -> Used to delete the
the elemen from the       |telemen from the queue
stack.                    |
vi)Stack doesn't have any |vi)Queue has various type like
type.                     |general queue, circular queue
                      | and doubly queue
vii)In stack only one     |vii)But, in queue two different
pointer is used  i.e Top  |point are used i.e Rear & Front.
of the stack.             |


    <br><br>
    <h4>5)CIRCULAR QUEUE</h4>
    i)A circular queue is one in which the insertion of a new element is done at the 1st location of the queue if the last location of queue is full .<br>
    



    ii)a circular queue overcome the problem of unutiliged space in linear queue implemented as arrays .
    

    <h4>6)CIRCULAR QUEUE HAS FOLLOWING CONDITION </h4>

    i)front will always be pointing to the 1st element .<br>
    ii)If front = Rear the queue will be empty . <br>
    iii)each time a new element is inserted to the queue the Rear is incremented by one .<br>
    <pre>      Rear = Rear + 1</pre>
    iv)Each time on element is deleted from the queue the value of front is incremented by one .<br>

    <h4>7)INSERT AN ELEMENT IN CIRCULAR QUEUE ALGORITHM</h4>

    <pre>
        QINERT(QUEUE[MAX_SIZE],ITEM)
        Step 1 :- if(front == (Rear*1)% MAX_SIZE)
        write queue is overflow & Exit
        else
        take the value
        if(front == -1)
        set front = 0
        Rear = 0
        else
        Rear = (Rear+1)%MAX_SIZE
        [Assign value] Queue [Rear] = value
        [End if]
    Step 2 :- Exit
    </pre>

    <h4>8)DELETE AN ELEMENT IN CIRCULAR QUEUE ALGORITHM</h4>

    <pre>
    QDELETE(QUEUE[MAX_SIZE],ITEM)
    Step 1 :- if(front == -1)
	write queue is underflow & Exit
	else
	item = Queue[front]
	if(front == Rear)
	set front = -1
	Rear = -1
	else
	Rear = ((front+1)%MAX_SIZE)
	[End if]
Step 2 :- Exit
</pre>
<h4>9)DEQUEUE / DEQUE</h4>
i)A deque is a linear list in which elements can be added or remove at either end but not in the middle .<br>
ii)Deque is maintained by a circular array with pointers left and right which points two ends of deque .






<h4>10)INPUT RESTRICTED DEQUE</h4>
Allow insertion at only one end of the list but allow deletion at both ends 


<h4>11)OUTPUT RESTRICTED DEQUE</h4>


<h4>12)PRIORITY QUEUE</h4>
A priority queue is collection of elements such that each element has been assigned a priority such that the order in which elements are deleted & processed comes from the following rules . <br><br>
i)An element of higher priority is processed before the element with lower priority .<br>
ii)Two elements with the same priority are processed according to the order in which they were added to the queue . <br>
<h4>13)LINEAR SEARCH</h4>
-It is a very basic and simple search an element in given array by starting till the disred element is found.<br>
-In linear search we can find element in list of element.<br>
ALGORITHAM<br>
-----------------<br>
1)start<br>
2)let arr[Size]<br>
3)Store the element in arr<br>
4)let item<br>
5)print "enter the item"<br>
6)input item<br>
7)let flag = 0<br>
8)for(let i=0;i< size;i++)<br>
9)if(arr[i]=item)then<br>
10)set flag = i;<br>
[end for loop]<br>
11)if(flag = 0)then<br>
12)print "item is not present"<br>
13)else<br>
print "item is present and location is ",flag<br>
14)exit.
<br>
<h4>14)BINARY SEARCH</h4>
It is the devide an conquer searching technique in which we have to arrage the data in particular format before searching operation. After that we find the middle element of array compare with target element (searching element).<br>
If item is not found we again check the target element is greater than or less than middle element ,if it greater than we search right side of middle element otherwise left side of middle element.<br>
ALGORITHAM<br>
---------------<br>
<pre>
   binary_search(arr[],size,item)
1)start
2)let LB=0,UB= size -1 ,flag = 0,mid=0,item
3)print "Enter the searching item"
4)read item // you can also write input item
3)while(LB<=UB)
4)mid=LB+(UB-LB)/2    // you can also write (LB+UB)/2 .
5)if(arr[mid] = item)then
6)set flag = mid 
   [end if loop]
7)if(arr[mid]>item)Then
8)set UB=mid-1
9)else
  set LB = mid+1
    [End while loop]
</pre>

<h4>15)BUBBLE SORT</h4>
Bubble sort arrage n number of array element on proper position . It always arrange data in descending order or ascending order . 
<br>
ALGORITHAM<br>
--------------------<br>
<pre>
     Bubble_sort(arr[],size)
1)for(let i = 0;i< size;i++)
2)let flag = 0
3)for(let j=0;j< size-i-1;j++)
4)if(arr[j] > arr[j+1])
5)let temp = arr[j] 
6)set arr[j] = arr[j+1] 
7)set arr[j+1] = temp
8)set flag = 1 // flag is used for less time complexity
   [end if loop] 
   [end step 3 for loop] 
9)if(flag = 0)then break 
   [end step 1 for loop] 
10)exit.
</pre>
<h4>16)INSERTION SORT ALGORITHAM</h4> 
<pre>
     Insertion_sort(arr[],size)
1)for(let i=0;i< size;i++)
2)let j=1 
3)while(j>=i && arr[j]< arr[j-1])
4)let temp = arr[j] 
5)arr[j-1] = arr[j] 
6)arr[j] = temp
7)set j=j-1 // you can also write j--
   [End while loop] 
   [End for loop] 
8)Exit.
<h4>17)SELECTION SORT ALGORITHAM</h4>
<pre>
    Selection_sort(arr[],size)
1)for(let i=0;i< size-1;i++)
2)let min= -1 
3)for(let j=i;j< size;j++)
4)if(min > arr[j])
5)min = j
  [End if loop]
  [End step 3 for loop]
6)let temp = arr[i] 
7)set arr[i] = arr[min] 
8)set arr[min] = temp
  [End step 1 for loop] 
9)Exit.
</pre>

</pre>
</body>  
</html>