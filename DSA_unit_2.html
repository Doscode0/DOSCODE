<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="DSA_unit_2.css">
</head>
<body>

    1)QUEUE</h4>
    i) Queue is a Non-primitive linear data structure.<br>
    ii)It is an homogenous collection of element in which new elements are added at one end called the Rear end and the existing element are delected from other end called the front end.<br>
    iii)The first added element will be the first to be remove from the queue sothat queue is called FIFO(first-in-first-out).<br>
    iv)In queue Every insert operation Rear is incremented by one <br>
    <pre>                     R = R + 1 </pre>
    <h4>2)WRITE A ALGORITHAM FOR INSERTION OF QUEUE</h4>
    <pre>STEP-1:- Begin
        STEP-2:- if Rear = N Then 
               print "Overflow & Exit"
        STEP-3:- Input new item
        STEP-4:- Rear <- Rear+1
        STEP-5:- queue[Rear] <- item
        STEP-6:- exit.
        </pre>
        <h4>32)WRITE A ALGORITHAM FOR DELETION OF QUEUE</h4>
        <pre>STEP-1:- Begin
            STEP-2:- if Front = -1 Then 
                   print "underflow & Exit"
            STEP-3:- set item <- queue[Front]
            STEP-4:- Front <- Front + 1
            STEP-5:- print "item deleted"
            STEP-6:- exit.</pre>

<h4>3)PUSH AND POP CODE USING QUEUE</h4>
<pre>#include< stdio.h>
#define MAX_SIZE 3
int queue[MAX_SIZE];
int front = -1;
int rear = -1;
int main(){
    int choice,item;
    printf("1.insert\n2.delete\n3.display\n4.exit\n");
    while (1)
    {
    printf("Enter your choice:- ");
    scanf("%d",&choice);
    switch (choice)
    {
    case 1 :
    {
        if(rear==MAX_SIZE)
        {
            printf("Overflow & Exit...\n");
        }else{
            printf("Enter the number:- ");
            scanf("%d",&item);
            if(front == -1)
            {
                front = rear = 0;
            }else{
                rear++;
            }
            queue[rear] = item;
            printf("Item Inserted \n");
        }
    }break;
    case 2:
    {
        if(front == -1)
        {
            printf("Underflow & Exit... \n");
        }else{
            item = queue[front];
            if(front == rear){
                front = rear = -1;
            }else{
                front++;
            }printf("Item Deleted:- \n");
        }break;
    }
    case 3:
    {
        if(front == -1){
            printf("Queue is empty.\n");
        }else{
            printf("Queue element:- ");
            for(int i=front;i<=rear;i++){
                printf("%d ",queue[i]);
            }printf("\n");
        }break;
    }
    case 4:{
        printf("Exit\n");
        return 0;
    }
    default:
        break;
    }
    }
}</pre>

    <h4>4)DIFFERENCE BETWEEN STACK AND QUEUE</h4>
<pre>
       STACK                          QUEUE
__________________________|_______________________________
i)Stack follow LIFO       |i)Queue follow FIFO operation
operation i.e - last-     |i.e - first-in-first-out.
in-first-out              |
ii)Insertion and delection|ii)Insertion and delection takes 
take place one end.This   |place on opposite end.
end is called top of      | 
stack .                   |
iii)Stack perform two     |iii)Queue perform two operation
operation i.e 1) PUSH     | i.e 1)Rear
          2)POP       |     2)Front
iv)PUSH -> used to insert |iv)REAR -> Used to insert the
the element in stack.     |element in queue. 
v)POP -> Used to delete   |v)FRONT -> Used to delete the
the elemen from the       |telemen from the queue
stack.                    |
vi)Stack doesn't have any |vi)Queue has various type like
type.                     |general queue, circular queue
                      | and doubly queue
vii)In stack only one     |vii)But, in queue two different
pointer is used  i.e Top  |point are used i.e Rear & Front.
of the stack.             |


    <br><br>
    <h4>5)CIRCULAR QUEUE</h4>
    i)A circular queue is one in which the insertion of a new element is done at the 1st location of the queue if the last location of queue is full .<br>
    



    ii)a circular queue overcome the problem of unutiliged space in linear queue implemented as arrays .
    

    <h4>6)CIRCULAR QUEUE HAS FOLLOWING CONDITION </h4>

    i)front will always be pointing to the 1st element .<br>
    ii)If front = Rear the queue will be empty . <br>
    iii)each time a new element is inserted to the queue the Rear is incremented by one .<br>
    <pre>      Rear = Rear + 1</pre>
    iv)Each time on element is deleted from the queue the value of front is incremented by one .<br>

    <h4>7)INSERT AN ELEMENT IN CIRCULAR QUEUE ALGORITHM</h4>

    <pre>
        QINERT(QUEUE[MAX_SIZE],ITEM)
        Step 1 :- if(front == (Rear*1)% MAX_SIZE)
        write queue is overflow & Exit
        else
        take the value
        if(front == -1)
        set front = 0
        Rear = 0
        else
        Rear = (Rear+1)%MAX_SIZE
        [Assign value] Queue [Rear] = value
        [End if]
    Step 2 :- Exit
    </pre>

    <h4>8)DELETE AN ELEMENT IN CIRCULAR QUEUE ALGORITHM</h4>

    <pre>
    QDELETE(QUEUE[MAX_SIZE],ITEM)
    Step 1 :- if(front == -1)
	write queue is underflow & Exit
	else
	item = Queue[front]
	if(front == Rear)
	set front = -1
	Rear = -1
	else
	Rear = ((front+1)%MAX_SIZE)
	[End if]
Step 2 :- Exit
</pre>
<h4>9)DEQUEUE / DEQUE</h4>
i)A deque is a linear list in which elements can be added or remove at either end but not in the middle .<br>
ii)Deque is maintained by a circular array with pointers left and right which points two ends of deque .






<h4>10)INPUT RESTRICTED DEQUE</h4>
Allow insertion at only one end of the list but allow deletion at both ends 
<h4>11)OUTPUT RESTRICTED DEQUE</h4>
<h4>12)PRIORITY QUEUE</h4>
A priority queue is collection of elements such that each element has been assigned a priority such that the order in which elements are deleted & processed comes from the following rules . <br><br>
i)An element of higher priority is processed before the element with lower priority .<br>
ii)Two elements with the same priority are processed according to the order in which they were added to the queue . 


</body>
</html>