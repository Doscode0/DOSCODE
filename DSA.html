<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="DSA.css">
  <title>DSA NOTE</title>
  <link rel="icon" type="image" href="icon.jpeg">
</head>
<body>
  <div class="search-wrapper">
    <label for="search">Search Users</label>
    <input type="search" id="input" placeholder="Available soon...." onkeyup="searchFunction()">
  </div>
  <div class="user-cards" data-user-cards-container=""></div>
  <template data-user-template>
    <div class="card">
      <div class="header" data-header></div>
      <div class="body" data-body></div>
    </div>
  </template>
  <div class="content-container" id="content">

  <h4 id="p">1)DATA:</h4>
 


Data is a collection of row facts and information.

<h4 id="p">2)DATA STRUCTURE:</h4>
Organised collection of data in particular format called data structure.data structure is a technique or method of study how the data are interrelated to each other logically or mathematically.
<h4 id="p">3)PURPOSE OF DATA STRUCTURE:</h4>
The main aim of data structure is to increase the efficiency of program and decrease the storage requirement.
<h4 id="p"> 4)CLASSIFICATION OF DATA STRUCTURE:</h4>
<pre>a)linear :         
    (i)graph                    
    (ii)linked list            
    (iii)stack
    (iv)queue
    (v)array

        OR

non linear :
     (i)Graph
     (ii)tree

b)homogenous :
     (i)array  

        OR

non homogenous
     (i)structure
     (ii)union

c)static :
(i)char a[10]

        OR

dynamic :
(i)*a
</pre>

<h4 id="p">5)WHAT IS ALGORITHIM ?</h4>

The step by step description of any program in general language is called algorithim.

<pre>         OR </pre>

 algorithim is a sequence of an clear instruction used to solving a problem .such a way that it can implimented as a program for computer.

 <h4 id="p" >6)CHARACTERISTICS OF ALGORITHIM</h4>
 <pre>
a)input-o or more well defined inputs
b)output-must generate atleast one output
c)umambigious/definiteness
d)finiteness
e)effectiveness
 </pre>
 <h4>STANDARD NOTATION OF ALGORITHM</h4>

For maintaining uniformity standard notation of algoritham are used as follows.<br>
1> Documentation need to be written within [and]
<br>
2> Start at the Beginning and stop at end .<br>
3>step no's required for each statement .<br>
ex :- step 1,step 2,step :-3.....<br>
4> Declaration shall be using let 
<br>
ex:- let x,y<br>
5> Assignment statement can be using '=' or := or '< -'<br>
ex :- x=35<br>
x := 35<br>
x < - 35 <br>
6> To input data we can use input / Accept / read <br>
7> To output data we can use Display / write / print .<br> 
<h4 id="p">7)DATATYPE AND ITS TYPE:</h4>
datatype is a type of data which is used in the program.In other word we can say that it is used to declare a variable.
<pre>            OR </pre>
datatype specify how we entered data in our program and what type of data we entred.

<h5>ITS TYPE</h5>
<pre>
i)Primary datatype<br>
ii)Secondary datatype

primary datatype :-

                  SIZE
                --------
Int     -        2 bytes  
char    -        1 bytes
float   -        4 bytes
void    -        no size


secondary datatype :-

1)Array
2)Pointer
3)Structure
4)Union</pre>

<h4>8)ABSTRAC DATA TYPE:</h4>

Mathematically model of data objects that make up a data type as well as the functions that operate these objects.
<br>

ex--lists,graph,array along with their objects(abstrac datatype)


<h4>DIFFERENCE BETWEEN LINEAR AND NONLINEAR</h4>

<pre>
  9) 
  LINEAR DATA STRUCTURE         |        NON LINEAR DATA STRUCTURE
  ______________________________|_______________________________________
i>In this data structure The    |i>In the data structure data is organaised
 elements are organised in      | without any sequence..
 a sequence such as..           |
    ex- array,srack etc         | ex-tree,graph etc
ii>In linear data structure     |ii>In non linear d.s multiple
single level is involved.       | levels are  involved.                               |  
iii>it is easy to implement.    |iii>it is difficult to implement.
iv>data element can transfered  |iv>data elements cannot be treversed in 
 in a single run only.          | single run only.
v>memory is not utiliged in a   | v>memory utiligation in an efficient
efficient way.                  |  way.
                              
</pre>
<h4>10)DATA STRUCTURE:</h4>

Data structure is of two types there are <br> i) Primitive( ex-int,float,char,double)<br>
<br>
ii) Non primitive
<br>
<br>
Non primitive data structure is of two types <br> 1)Linear <br>
ii)Non-linear
<br>
<br>
Linear d.s is of two types (i.e :- static,dynamic)<br<br>
Non-linear d.s is of two types (i.e :- tree,graph)
<h4>11)ALGORITHIM COMPLEXITY:-</h4>
Algorithim complexity refers to the analysis of an algorithim performance in term of time and space requirement as a function of input size.
<h4>12)SPACE COMPLEXITY:-</h4>
Total amount of memory required by an algorithim for its complete execution called space complexity
<h4>13) CONSTANT SPACE COMPLEXITY:-</h4>
If any algorithim requires fixed amount of space then the space complexity is called constant space complexity.
<pre>
  Ex - int sqrt(int n){
    return n*n;
    }
</pre>
<h4>14)LINEAR SPACE COMPLEXITY</h4>
If the amount of space required by algorithim is increase of input values then that space complexity is called linear space complexity.
<pre>
  EX-int sum(int arr[],int n){
    int sum=0;
    for(int sum i=0;i<=n;i++)
         {
            sum=sum+arr[i];
          }
    return sum;
    }
</pre>
<h4>15) TIME COMPLEXITY:-</h4>
Total amount of time required by an algorithim to its complete execution called time complexity.
<h4>16) CONSTANT SPACE COMPLEXITY</h4>
If any algorithim required fixed amount of space then the space complexity which said to be const space complexity.
<pre>
  Ex-
  int sqrt(int n)
    {
      return n*n;
     }
</pre>
<h4>17)LINEAR TIME COMPLEXITY:</h4>
If the amount of space required by algorithim is increase of input values then that space complexity is called linear space complexity.
<pre>
  int sum(int a[],int n)
  {
    int sum=0;
    for (int i=0;i< n;i++)
      {
        sum=sum+a[i];
       }
    return sum;
  }
</pre>
<h4>18)DATA SPACE:</h4>
It is the amount of memory use to store all the variable and constant.
<h4>19)ARRAY</h4>
a)Array is derived data type which is constured by the help of primitive  data type.
b)Array is a variable which store more than one values of same data types in a continuous memory location.
<h4>20)LINEAR ARRAY</h4>
-A linear array is a list of a finite number n of homogenous data elements(i.e:- data element of same time )such that -
  a)The elements of the array are referenced respetively by an index set consecutive numbers.
  b)The elements of the array are stored respetively in successive memory location.
<h4>21)DIFFERENT TYPES OF OPERATION IN ARRAY LINEAR DATA STRUCTURE</h4>
<pre>
  a)TRAVERSAL:- 
  I)Processing each element in list.
  II)search finding the location of element finding the location of element with a given value.

b)INSERTION:-
  -Adding new element of list

c)DELETION:-
  -Removing elements from list.

d)SORTING:-
  -Arranging the elements in sum type of order.

E)MERGING:-
  -Combining to list to be a single list.
</pre>
<h4>22)TRAVERSING IN A LINEAR ARRAY </h4>
<pre>
    TRAVERSAL(arr[],n)
i)for(let i=0 to n-`)increase by 1
ii)[Now visit all elements]  
iii)print arr[i]
iv)[end step -1 for loop] 
v)exit
</pre>
<h4>23.INSERTION IN LINEAR ARRAYS</h4>
<pre>
 Here capacity is max size of array , n is size of arrey stored element  , index is use for to input element in specific location and item is use for to input insert element . <br>
      INSERTION(arr[capacity],n,index,item)
i)if(size>=capacity)then
print "Overflow" & exit
   else
i)for(let i=index to size-1)decrease by 1
iii)set arr[i+1]=arr[i] 
   [end for loop]
iv)set arr[index]= item
   [end else loop]
v)set n=n+1
vi)exit
</pre>

<h4>23.INSERTION IN LINEAR ARRAYS CODE</h4><pre>
#include<  stdio.h>
  int insertion(int arr[],int size,int element, int capacity,int index)
  {
      if(size>=capacity)
      {
          return -1;
      }
      else{
          for(int i=size-1;i>=index;i--)
          {
              arr[i+1]=arr[i];
          }
          arr[index]=element;
          return 1;
      }
  }
  int main()
  {
      int n,arr[100];
      printf("Enter the size of array:- ");
      scanf("%d",&n);
      printf("Enter the array elements:- ");
      for(int i=0;i< n;i++)
      {
          scanf("%d",&arr[i]);
      }
      printf("Enter the adding index number:- ");
      int index,element;
      scanf("%d",&index);
      printf("Enter adding element:- ");
      scanf("%d",&element);
      insertion(arr,n,element,100,index);
      n +=1;//n=n+1;
      // for display result .....
      printf("Inserted array is :- ");</pre><pre>
        for(int i=0;i< n;i++)
      {
          printf("%d",arr[i]);
      }
      return 0;
  }
      </pre> </pre>
<h4>24)DELETION FROM ARRAYS</h4>
        <pre>       DELETE(A,N,k,ITEM)
    DELETION(arr[],n)
i)Start
ii)for(let i = size-1 to index)increase by 1
iii)set arr[i] = arr[i+1]
    [end for loop]
iv)set n= n-1
v)exit

 </pre>

</div>
<h4>25)DELETION FROM ARRAYS CODE</h4>

<pre>#include< stdio.h>
  int delection(int arr[],int size,int index)
  {
      for(int i=index;i< size-1;i++)
      {
          arr[i]=arr[i+1];
      }
  }
  int main()
  {
      printf("Enter array size:- ");
      int n;
      scanf("%d",&n);
      int arr[n];
      printf("Enter the array element:- ");
      for(int i=0;i< n;i++)
      {
          scanf("%d",&arr[i]);
      }
      printf("Enter the delete index:- ");
      int index;
      scanf("%d",&index);
      delection(arr,n,index);
      n -=1;// n=n-1;
      //  for see the changes simplely print the array
      for(int i=0;i< n;i++)
      {
          printf("%d ",arr[i]);
      } return 0;
  }</pre>
  <h4>26)BUBBLE SORT</h4>
  DEFINATION:- <br>
  -------------------<br>

    bubble sort arrange N number of array  elements by plaing the biggest element on proper position.It always arrange data in descending order.<br>
  
  ex-a[5]={7,6,3,9,0}<br>
  
  OUTPUT:-{0,3,6,7,9}
  <br><br>
  ALGORITHAM:-<br>
  ----------------------<br>
  <pre>
    BUBBLESORT(arr[100],size)
Step-1:  Begin
ii)for(let i = 0 to size-1)increase by one 
iii)let set flag = 0
iv)for(let j = 0 to size - i) increase ny one 
v)if(arr[j]>arr[j+1])then
vi) let set temp = arr[j]
       set arr[j] = arr[j+1]
       set arr[j+1] = temp
       set flag = 1 
    [end if loop]
    [end set iii for loop]
vii)if(flag = 0)then
    break and exit
    [end step ii for loop]


    </pre>
/* Here flag is use for less time complexity */
  
    <h4>27)BUBBLE SORT CODE</h4>
    <pre>
      #include< stdio.h>
      void bubble(int arr[],int n);
      int main()
      {
          int n;
          printf("Enter the size of array:- ");
          scanf("%d",&n);
          int arr[n];
          printf("Enter array elements:- ");
          for(int i=0;i< n;i++)
          {
              scanf("%d",&arr[i]);
          }
          bubble(arr,n);
          /*Now you print the array to see changes*/
          for(int i=0;i< n;i++)
          {
              printf("%d",arr[i]);
          }
          return 0;
      }
      void bubble(int arr[],int n)
      {
          for(int i=0;i< n-1;i++)
          {
              for(int j=0;j< n-1-i;j++)
              {
                  if(arr[j]>arr[j+1])
                  {
                      int satya = arr[j];/* you can also take 'temp' in place of satya*/
                      arr[j] = arr[j+1];
                      arr[j+1] = satya;
                  }
              }
          }
      }</pre>
  
<h4>28)LINEAR SEARCH</h4>
DEFINATION:- <br>
--------------------<br>
It is a very basic and simple search an element in given array by travesing the any from the starting till the disred element is found.<br>
<br>
ALGORITHM:-<br>
--------------------<br>
<pre>
    LINEARSEARCH(arr[],n,item)
i)Start
ii)let set loc = 0
iii)for(let i=0 to n-1)increase by 1
iv)if(arr[i]=item)then
    set loc = loc+1
    [end if loop]
    [end for loop]
v)if(loc>=1)then
    print "Item is present"
    [closed if loop]
    else
    print "Item is not present"
    [end else loop]
</pre>
<h4>29)LINEAR SEARCH CODE</h4>

<pre>#include< stdio.h>
  int main()
  {
      int n;
      printf("Enter the array size:- ");
      scanf("%d",&n);
      printf("Enter the array element:- ");
      int arr[n];
      for(int i=0;i< n;i++)
      {
          scanf("%d",&arr[i]);
      }
      printf("Enter the searching element:- ");
      int item;int loc=0;
      scanf("%d",&item);
      for(int i=0;i< n;i++)
      {
          if(arr[i]==item)
          {
               printf("Searching item is available and index is %d ",i);
              loc = loc + 1;
          }
      }
      if(loc==0)
      {
           printf("searching item is not available...");
      }
      return 0;
  }</pre>

<h4>30)BINARY SEARCH</h4>
It is the devide an conquer searching technique in which we have to arrage the data in particular format before searching operation .After that we find the middle element of array an campare with target element(searching element).<br>
If item is not found the we again cheak the target elements is greater than or less than middle element, if it greater than we search right side of middle element otherwise left side of middle element.<br><br>
ALGORITHM:-<br>
-------------------
<br>
<pre>
    BINARYSEARCH(arr[],UB,LB,item)
Step-1: start
ii)let mid
iii)while(LB< UB)
iv)set mid = (UB+LB)/2
v)if(arr[mid]=item)then
   print "present" & break
   else
vi)if(arr[mid]< item)
    LB = mid +1
    [end if loop]
    else
    set UB = mid - 1
    [end else loop]
    [end while loop]
vii)Exit
 </pre>


<h4>31)BINARY SEARCH CODE</h4>


<pre>#include< stdio.h>
  int binarysearch(int arr[],int size,int item);
  int main()
  {
      int n;
      printf("Enter the array size:- ");
      scanf("%d",&n);
      int lr=0;int up=n-1;
      int arr[n];
      printf("Enter the array element in Ascending Order:- ");
      for(int i=0;i< n;i++)
      {
          scanf("%d",&arr[i]);
      }
      printf("Enter the searching item:- ");
      int item;
      scanf("%d",&item);
      int bs=binarysearch(arr,n,item);
      if(bs==-1)
      {
          printf("no");
      }
      else{
          printf("yes and Location is %d",bs);
      }
      return 0;
  }
  int binarysearch( int arr[],int size,int item)
  {
      int lr=0,up=size-1;// here lr is lower and up is upper
      int f=0;int mid;
      while(lr<=up)
      {
          mid=(lr+up)/2;
          if(arr[mid]==item)
          {
              return mid;
          }
          if(arr[mid< item])
          {
              lr=mid+1;
          }else{
              up=mid-1;
          }
          return -1;
      }
  }
</pre>
<h4>32)SPARSE MATRIX</h4>
sparse matrices are those matrices which have the majority of their elements equal to zero.

ALGORITHAM<br>
-------------------
<h4>Write down the algorithm to test a matrix is sparse or not and if sparse store the non-zero information into another 3-column matrix.</h4>

 SPARSE(arr[100][],n,m)
 i)start
 ii)let nz = 0 ,z = 0 //while nz = none zero element or z = zero
 iii)for(let i = 0 to m-1)increase by 1
 iv)for(let j=0 to n-1 )increase by 1
 v)if(arr[i][j] = 0) then 
    set z = 0
    [end if loop]
    else
    set nz=0
    [end else loop]
    [end step iv for loop]
    [end step iii for loop]
vi)if(nz>z) then
Point "yes it is a sparse matrix"
    [end if loop]
else
vii)let set k = 0 , sp[n][n]
viii)for(let i = 0 to n-1)increase by 1
ix)for(let j=0 to n-1)
x)  if(arr[i][j] != 0)then
    set sp[k][0] = i
    set sp[k][1] = j
    set sp[k][2] = arr[i][j]
    set k++
    [end if loop]
    [end step ix loop]
    [end step viii for loop]
<h4>33)SPARSE MATRIX CODE</h4>
<pre>#include< stdio.h>
  int main(){
      int arr[3][3];
      printf("Enter the matrix number");
      for(int i=0;i< 3;i++)
      {
          for(int j=0;j< 3;j++)
          {
              scanf("%d",&arr[i][j]);
          }
      }
      /*IT is use for to see the input matrix it is not necessary if you want to see input matrix then write */
      printf("\nInput matrix is\n");
      for(int i=0;i< 3;i++)
      {
          for(int j=0;j< 3;j++)
          {
              printf("%d ",arr[i][j]);
          }printf("\n");
      }
      int count=0;int z=0, nz=0;/* here z= zero ,nz= none zero  */
      for(int i=0;i< 3;i++)
      {
          for(int j=0;j< 3;j++)
          {
              if(arr[i][j]==0)
              {
                  z +=1;// z++
              }else{
                  nz +=1;//  nz++
              }
          }
      } int sparse[nz][z]; int k=0;
       if(nz>z)
          {
              printf("\nNot a sparse matrix:- ");
          }
          else{
              for(int i=0;i< 3;i++)
              {
                  for(int j=0;j< 3;j++)
                  {
                      if(arr[i][j]!=0)
                      {
                          sparse[k][0]=i;
                          sparse[k][1]=j;
                          sparse[k][2]=arr[i][j];
                          k++;
                          /*Now print the sparse matrix*/
                      }
                  }
              }
          } printf("\nsparse matrix is:- \n");
                       for(int i=0;i< nz;i++)
                      {
                          for(int j=0;j< 3;j++)
                          {
                            printf("%d ",sparse[i][j]);
                          }printf("\n");
                      }return 0;
  }</pre>
  <h4>34)WHAT IS INFIX AND POSTFIX ?</h4>

  <h4>35)INFIX TO POSTFIX USING STACK CODE</h4>
  <pre>#include < stdio.h>
    #include < stdlib.h>
    #include < string.h>
     
    struct stack
    {
        int size;
        int top;
        char *arr;
    };
     
    int stackTop(struct stack* sp){
        return sp->arr[sp->top];
    }
     
    int isEmpty(struct stack *ptr)
    {
        if (ptr->top == -1)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
     
    int isFull(struct stack *ptr)
    {
        if (ptr->top == ptr->size - 1)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
     
    void push(struct stack* ptr, char val){
        if(isFull(ptr)){
            printf("Stack Overflow! Cannot push %d to the stack\n", val);
        }
        else{
            ptr->top++;
            ptr->arr[ptr->top] = val;
        }
    }
     
    char pop(struct stack* ptr){
        if(isEmpty(ptr)){
            printf("Stack Underflow ! Cannot pop from the stack\n");
            return -1;
        }
        else{
            char val = ptr->arr[ptr->top];
            ptr->top--;
            return val;
        }
    }
    int precedence(char ch){
        if(ch == '*' || ch=='/')
            return 3;
        else if(ch == '+' || ch=='-')
            return 2; 
        else
            return 0;
    }
     
    int isOperator(char ch){
        if(ch=='+' || ch=='-' ||ch=='*' || ch=='/') 
            return 1;
        else
            return 0;
    }
    char* infixToPostfix(char* infix){
        struct stack * sp = (struct stack *) malloc(sizeof(struct stack));
        sp->size = 10; 
        sp->top = -1;
        sp->arr = (char *) malloc(sp->size * sizeof(char));
        char * postfix = (char *) malloc((strlen(infix)+1) * sizeof(char));
        int i=0; 
        int j = 0; 
        while (infix[i]!='\0')
        {
            if(!isOperator(infix[i])){
                postfix[j] = infix[i];
                j++;
                i++;
            }
            else{
                if(precedence(infix[i])> precedence(stackTop(sp))){
                    push(sp, infix[i]);
                    i++;
                }
                else{
                    postfix[j] = pop(sp);
                    j++;
                }
            }
        }
        while (!isEmpty(sp))    
        {
            postfix[j] = pop(sp);
            j++;
        }
        postfix[j] = '\0';
        return postfix;
    }
    int main()
    {
        char infix[100];
        printf("Enter the expression:- ");
        scanf("%s",infix);
        printf("postfix is %s", infixToPostfix(infix));
        return 0;
    }
    </pre>
<h4>36)STACK</h4>
 i)A Stack is an ordered collection of homogenous data elements, Where the insertion and deletion take place at one end know as top.<br>
 ii)The Stack also called as LIFO(last in first out).Its means the element which is inserted last must be delected first.
 <h4>37)WRITE A ALGORITHAM FOR PUSH OPERATION USING STACK</h4>
 <pre>STEP-1:- Begin
    STEP-2:- if Top = N Then 
           print "Overflow & Exit"
    STEP-3:- input new item
    STEP-4:- Top=Top+1
    STEP-5:- stack[Top] <- item
    STEP-6:- exit.</pre>
    <h4>38)WRITE A ALGORITHAM FOR POP OPERATION USING STACK</h4>
    <pre>STEP-1:- Begin
        STEP-2:- if Top = -1 Then 
               print "Overflow & Exit"
        STEP-3:- set item <- stack[Top]
        STEP-4:- Top <- Top-1
        STEP-5:- print "item deleted"
        STEP-6:- exit.
        </pre>
    <h4>39)PUSH AND POP CODE USING STACK</h4>
    <pre>#include< stdio.h>
        #define MAX_SIZE 5
        int stack[MAX_SIZE];
        int top = -1;
        void push(int item){
            if(top==MAX_SIZE-1){
                printf("Overflow ! & Exit\n");
            }else{
                stack[++top] = item;
                printf("%d Item Inserted.\n",item);
            }
        }
        void pop(){
            if(top == -1)
            {
                printf("Underflow & Exit\n");
            }else{
                int Item = stack[top--];
                printf("%d Item DEleted.\n",Item);
            }
        }
        void display(){
            if(top == -1){
                printf("The stack is empty");
            }else{
                printf("stack element:- ");
                for(int i=0;i<= top;i++){
                    printf("%d ",stack[i]);
                }printf("\n");
            }
        }
        int main()
        {
            int choice,item;
            printf(" 1.Push\n 2.Pop\n 3.Display\n 4.Exit\n");
            while (1)
            {
                printf("Enter your choice:- ");
                scanf("%d",&choice);
               switch(choice)
               {
                case 1:
                {
                    printf("Enter value to Push:- ");
                    scanf("%d",&item);
                    push(item);break;
                }
                case 2:
                {
                    pop();break;
                }
                case 3:
                {
                    display();break;
                }
                case 4:
                {
                    return 0;
                }
                default :{
                    printf("Invalid choice...\n");
                }
        
               }
            }
            return 0;
        }</pre><br><br>
    </div>













        <pre>__________________________________________</pre>
        <pre>|             UNIT-1 completed            |  </pre><pre>|_________________________________________|</pre>

        <pre>             Thank you </pre><br>
  <h3>Join Us In WhatsApp...To Know All Update</h3>
  <a href="https://chat.whatsapp.com/EXHLJO97dzzDxYOS4HiEgK">https://chat.whatsapp.com/EXHLJO97dzzDxYOS4HiEgK</a><br><br><br>
</body>
</html>